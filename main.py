from perlinNoise import perlin
import matplotlib.pyplot as plt
import pygame
from slider import LabeledSlider
import pygame_widgets
from pygame_widgets.textbox import TextBox
from pygame_widgets.button import Button

import numpy as np
# best way to implement this into pygame. 
# want to be able to edit the map in the future? 
# pixel by pixel storage of colours? 
# have a noisemap, as generated by noise functions. Want pygame to handle purely the map, so we can make alterations to it before?
# want to be combining multiple maps into biome mappings. 
# so maybe 3 maps combined, and then each twile is assigned a biome texture. 
# need to account for biome texture options? IF can upload an image, then probably don't want to just assign a colour. Although for time being maybe the best option.
# perhaps make the noise map generated the same size as the default pygame window 

#todo
# 
#ocean depth colouring, same with mountains etc.
#
#
#


# menu class to display widgets
# initialise pygame and constants
pygame.init()
WIDTH = 1024
HEIGHT = 756
perlin_width = 512
perlin_height = 512
MENU_WIDTH = 256

windows = {"menu":True,        # have windows be displayed depending on whether they are active or not. 
            "import":False, 
            "generation":False,
            "view_map":False, 
            "help":False} 


screen = pygame.display.set_mode((WIDTH+MENU_WIDTH, HEIGHT), flags=pygame.RESIZABLE)
clock = pygame.time.Clock()
FPS = 60


class Menu():
    def __init__(self, screen, x, y):
        self.sliders = []
        self.buttons = []
        self.screen = screen
        self.values_dict = {}
        self.x = x
        self.y = y
    
    def add_slider(self, screen, x, y, slider_width, slider_height, slider_min, slider_max, slider_step, label_text, key):
        self.sliders.append(LabeledSlider(screen, x, y, slider_width, slider_height, slider_min, slider_max, slider_step, label_text, key=key, label_fontsize=15))

    def add_button(self, screen, x, y, width, height, text):
        params = self.values_dict.values()
        self.buttons.append(Button(screen, x, y, width, height, text=text, onClick=self.on_button_click))  

    def on_button_click(self):
        params = self.values_dict
        print(self.values_dict)
        global rgb_array # is using a global variable bad practice? can get around this? 

        rgb_array,noise_map = generate_rgb_map(
            perlin_width,
            perlin_height, 
            octaves= params["octaves"], 
            frequency=params["frequency"], 
            amplitude=params["amplitude"], 
            persistence=params["persistence"], 
            lacunarity=params["lacunarity"], 
            SEED= 0, 
            blue_bound=params["blue_boundary"], 
            green_bound=params["green_boundary"])
        

    def update(self):
        for obj in self.sliders:
            self.values_dict[obj.key] = obj.update() # store slider values in self dictionary. uses key identifier





def generate_rgb_map(perlin_width=perlin_width, perlin_height=perlin_height, octaves= 1, frequency= 1, amplitude= 1, persistence=0.5, lacunarity= 2, SEED= 0, blue_bound=-0.15, green_bound=0.3):
    print(locals())
    noise_map = perlin(perlin_width,perlin_height,octaves, frequency, amplitude, persistence, lacunarity, SEED)
    rgb_array = np.zeros((perlin_width,perlin_height,3), dtype=np.uint8) # 3 deep for RGB, unit provides range from 0-255
    # boolean array indexing, masks perlin values to colour

    rgb_array[(noise_map >= -1) & (noise_map < blue_bound)] = (0,0,255) # blue masking
    rgb_array[(noise_map >= blue_bound) & (noise_map < green_bound)] = (0,255,0) # green masking
    rgb_array[(noise_map >= green_bound) & (noise_map <= 1.0)] = (190,190,190) # gray masking



    return rgb_array,noise_map # returns an array of rgb values, and the originally generated perlin noise map. 





# initialise settings menu
generation_menu = Menu(screen, 512, 0)
generation_menu.add_slider(screen=screen, x=550, y=30, slider_width=MENU_WIDTH, slider_height=15, slider_min=1, slider_max=16, slider_step=1, label_text="Octaves", key="octaves")
generation_menu.add_slider(screen=screen, x=550, y=130, slider_width=MENU_WIDTH, slider_height=15, slider_min=1, slider_max=32, slider_step=0.25, label_text="Frequency", key="frequency")
generation_menu.add_slider(screen=screen, x=550, y=230, slider_width=MENU_WIDTH, slider_height=15, slider_min=1, slider_max=32, slider_step=0.25, label_text="Amplitude", key="amplitude")
generation_menu.add_slider(screen=screen, x=550, y=330, slider_width=MENU_WIDTH, slider_height=15, slider_min=0, slider_max=2, slider_step=0.25, label_text="Persistence", key="persistence")
generation_menu.add_slider(screen=screen, x=550, y=430, slider_width=MENU_WIDTH, slider_height=15, slider_min=0, slider_max=4, slider_step=0.5, label_text="Lacunarity", key="lacunarity")
generation_menu.add_slider(screen=screen, x=20, y=550, slider_width=100, slider_height=15, slider_min=-1.0, slider_max=1, slider_step=0.01, label_text="Blue Noise Boundary", key="blue_boundary")
generation_menu.add_slider(screen=screen, x=20, y=650, slider_width=100, slider_height=15, slider_min=-1.0, slider_max=1, slider_step=0.01, label_text="Green Noise Boundary", key="green_boundary")

generation_menu.add_button(screen=screen, x=550, y=530, width = 100, height = 30, text= "Generate")


map_surf = pygame.Surface((perlin_width, perlin_height)) # map surface
rgb_array,noise_map = generate_rgb_map()

# noise_map = perlin(perlin_width,perlin_height,frequency=4, octaves=6, SEED=2) # np array


#run loop
running = True
while running:
    events = pygame.event.get()
    for event in events:
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            pos = pygame.mouse.get_pos()
            print(pos)
            try:
                print(noise_map[pos[0]][pos[1]])
            except:
                pass
    screen.fill((255,255,255))

    pygame.surfarray.blit_array(map_surf, rgb_array)
    screen.blit(map_surf, (0,0))

    slider_vars = generation_menu.update()
    pygame_widgets.update(events)

    pygame.display.flip()
    clock.tick(FPS)



print(slider_vars)