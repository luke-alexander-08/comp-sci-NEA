from perlinNoise import perlin
import matplotlib.pyplot as plt
import pygame
from slider import LabeledSlider
from menus import Menu, GenerationMenu, WelcomeMenu, HelpMenu, MapMenu, ImportMenu, LoadingMenu

import pygame_widgets
from pygame_widgets.textbox import TextBox
from pygame_widgets.button import Button
from perlin_mapping import noise_map_to_biome_map, rules
from pygame_widgets.progressbar import ProgressBar

import numpy as np
# best way to implement this into pygame. 
# want to be able to edit the map in the future? 
# pixel by pixel storage of colours? -
# have a noisemap, as generated by noise functions. Want pygame to handle purely the map, so we can make alterations to it before?
# want to be combining multiple maps into biome mappings. 
# so maybe 3 maps combined, and then each twile is assigned a biome texture. 
# need to account for biome texture options? IF can upload an image, then probably don't want to just assign a colour. Although for time being maybe the best option.
# perhaps make the noise map generated the same size as the default pygame window 

#todo
#ocean depth colouring, same with mountains etc.

# initialise pygame and constants
pygame.init()
pygame.font.init()
perlin_width = 512
perlin_height = 512
MENU_WIDTH = 256


class Program():
    def __init__(self):        
        self.WIDTH = 1024
        self.HEIGHT = 756
        self.perlin_width = 1024
        self.perlin_height = 512
        self.MENU_WIDTH = 256

        self.screen = pygame.display.set_mode((self.WIDTH, self.HEIGHT), flags=pygame.RESIZABLE)
        self.screen.fill((255,255,255))

        self.map_array = np.zeros((perlin_width,perlin_height,3), dtype=np.uint8)

        #pygame variables
        self.events = pygame.event.get()
        self.clock = pygame.time.Clock()
        self.FPS = 60
        self.screenshot_num = 0
        self.perlin_progress = 0.0

        self.current_window = WelcomeMenu(self.screen,0,0, self.WIDTH, self.HEIGHT, self.screen_change, self.go_back_screen)
        self.window_stack = [] # manage navigating back through windows
        self.windows = {        # have windows be displayed depedning on activity                  # give windows an "on" and an "off" attribute.        

            "WELCOME": self.current_window,
            "GENERATION": GenerationMenu(self.screen, 0,0,self.WIDTH, self.HEIGHT, self.MENU_WIDTH, self.screen_change, self.go_back_screen, self.gen_map),
            "IMPORT": ImportMenu(self.screen, 0,0, self.WIDTH, self.HEIGHT, self.screen_change, self.go_back_screen, self.import_map),
            "HELP": HelpMenu(self.screen, 0,0, self.WIDTH, self.HEIGHT, self.screen_change, self.go_back_screen),
            "MAP": MapMenu(self.screen, 0,0, self.WIDTH, self.HEIGHT, self.screen_change, self.go_back_screen, self.map_array, self.perlin_width, self.perlin_height, view_libs=self.view_libs),
            "LOAD": LoadingMenu(self.screen, 0,0, self.WIDTH, self.HEIGHT, self.screen_change, self.go_back_screen, self.get_perlin_progress)
       
        } 
        
        self.window_stack.append(self.current_window.get_ID())



        # self.current_window = self.windows["GENERATION"]
        self.current_window.show_self()

        for val in self.windows.values():
            val.hide_self()

        self.running = True

        print(self.current_window.get_ID())


    def run(self):
        if self.run:            
            self.screen.fill((255,255,255))

            self.events = pygame.event.get()
            for event in self.events:
                if event.type == pygame.QUIT:
                    self.running = False
                    print("End")
                
                if self.current_window.ID == "MAP":
                    if event.type == pygame.MOUSEMOTION: 
                        if event.buttons[1]: # buttons is an attribute of MOUSEMOTION event, so check if it is middle mouse after to avoid crashes. 
                            self.current_window.set_pan(pygame.Vector2(event.rel)) # rel gives motion from where movement initially clicked. so pan is adjusted to fit it. 
                    if event.type == pygame.MOUSEWHEEL:
                        mouse_pos = pygame.Vector2(pygame.mouse.get_pos())
                        if event.y > 0:
                            self.current_window.zoom_map(mouse_pos, "IN")
                            print("IN")
                        elif event.y < 0:
                            self.current_window.zoom_map(mouse_pos, "OUT")
                            print("OUT")

                    if event.type == pygame.MOUSEBUTTONDOWN and pygame.mouse.get_pressed()[0] and self.current_window.edit_menu.placing_label:
                        print("click!")
                        self.current_window.edit_menu.placing_label = False # stop label following mouse, so it remains in position placed. 
                if event.type == pygame.MOUSEBUTTONDOWN:
                    pos = pygame.mouse.get_pos()
                    print(pos)
                    try:
                        print(rules.biomes[self.array_ids[pos[0], pos[1]]])
                        print(f"altitude:{self.altitude_map[pos[0], pos[1]]}, moisture:{self.moisture_map[pos[0], pos[1]]}, temperature:{self.temperature_map[pos[0], pos[1]]}")
                    except:
                        pass
                


            self.current_window.show_self()
            self.current_window.update()

            pygame_widgets.update(self.events)
            # if self.current_window.ID == "LOAD":
            #     pygame.image.save(self.screen,f"screenshots/screenshot{self.screenshot_num}.png")
            #     self.screenshot_num +=1 
            pygame.display.flip()
            self.clock.tick(self.FPS)           

    # def perlin_noise_progress(self, total_octaves, current_octave):
    #     x = current_octave/total_octaves
    #     # self.perlin_progress=x
    #     return x
    
    def set_perlin_progress(self, octaves=None, current_octaves=None):
        if octaves != None and current_octaves != None:
            x = current_octaves/octaves
        else:
            x = 0 
        
        print(x)
        self.perlin_progress = x
    
    def get_perlin_progress(self):
        return self.perlin_progress

    def screen_change(self, key):
        self.current_window.hide_self()   
        self.current_window = self.windows[key]
        self.current_window.on_open()
        self.current_window.show_self()
        if self.current_window.get_ID() != "LOAD":
            self.window_stack.append(self.current_window.get_ID()) #pushed onto window stack
        print(self.window_stack)
        print(self.windows)
        # window stack example: ['WELCOME', 'GENERATION', 'MAP', 'WELCOME', 'IMPORT', 'WELCOME']


    def go_back_screen(self):
        if len(self.window_stack) > 1:
            self.current_window.hide_self()
            self.window_stack.pop()
            self.current_window = self.windows[self.window_stack[-1]] # get last screen in stack list
            self.current_window.on_open()
            self.current_window.show_self()
            
        else:
            print("Stack Empty")

    def gen_map(self, params, seed):
        print("Gen map! ")
        print(params)

        self.windows["LOAD"].setloadingtext("Loading Altitude")
        self.altitude_map = perlin(
            self.perlin_width,
            self.perlin_height,
            octaves= params["altitude_octaves"],
            frequency=params["altitude_frequency"],
            amplitude=params["altitude_amplitude"],
            persistence=params["altitude_persistence"],
            lacunarity=params["altitude_lacunarity"],
            SEED= seed, perlin_progress=self.set_perlin_progress, game_loop=self.run)
        
        self.windows["LOAD"].setloadingtext("Loading Moisture")
        self.moisture_map = perlin(
            self.perlin_width,
            self.perlin_height,
            octaves= params["moisture_octaves"],
            frequency=params["moisture_frequency"],
            amplitude=params["moisture_amplitude"],
            persistence=params["moisture_persistence"],
            lacunarity=params["moisture_lacunarity"],
            SEED= seed, perlin_progress=self.set_perlin_progress, game_loop=self.run)

        self.windows["LOAD"].setloadingtext("Loading Temperature")
        self.temperature_map = perlin(
            self.perlin_width,
            self.perlin_height,
            octaves= params["temperature_octaves"],
            frequency=params["temperature_frequency"],
            amplitude=params["temperature_amplitude"],
            persistence=params["temperature_persistence"],
            lacunarity=params["temperature_lacunarity"],
            SEED= seed, perlin_progress=self.set_perlin_progress, game_loop=self.run)


        self.convert_noise_to_map(altitude_map=self.altitude_map, 
                                      temperature_map=self.temperature_map,
                                      moisture_map=self.moisture_map)

    def convert_noise_to_map(self, altitude_map, temperature_map, moisture_map):
        # normalise
        self.altitude_map = (altitude_map+1) /2
        self.temperature_map = (temperature_map+1) /2
        self.moisture_map = (moisture_map+1) /2

        self.map_array, self.array_ids = noise_map_to_biome_map(self.altitude_map, self.moisture_map, self.temperature_map, self.perlin_width, self.perlin_height)

        self.windows["MAP"].set_map(self.map_array)
        self.screen_change("MAP")
        
    def import_map(self, map_file): # the issue is that not all 3 maps are saved maybe? 
        self.map_array = np.load(f"./maps/{map_file}")
        self.map_array.transpose()
        print(self.map_array)
        shape = self.map_array.shape

        self.windows["MAP"].set_map_size(shape[0], shape[1])
        print(self.map_array.ndim)
        self.windows["MAP"].set_map(self.map_array, imported=True)
        print(self.map_array.shape)
        self.screen_change("MAP") 

    def view_libs(self):
        plt.figure(figsize=(10,8))
        plt.imshow(self.altitude_map, cmap="viridis", origin="lower", vmin=0, vmax=1.0)
        plt.colorbar(label='Noise Value')
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.title("Altitude")
        plt.show()

        plt.figure(figsize=(10,8))
        plt.imshow(self.moisture_map, cmap="viridis", origin="lower", vmin=0, vmax=1.0)
        plt.colorbar(label='Noise Value')
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.title("Moisture")
        plt.show()
    
        plt.figure(figsize=(10,8))
        plt.imshow(self.temperature_map, cmap="viridis", origin="lower", vmin=0, vmax=1.0)
        plt.colorbar(label='Noise Value')
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.title("Temperature")
        plt.show()
     

pmain = Program()


# 12/10/2025 - currently at the point of implementing screens. need to create a welcome menu screen and implement true/false switching within the program class. then work on page nav & adding a perlin function into the program classs. 
# 17/10/2025 - sorted screen functionality, can move back and forth use buttons etc. Next step is to work on layering multiple maps generated. 
#run loop
while pmain.running:
    pmain.run()


