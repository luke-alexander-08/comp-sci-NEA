from perlinNoise import perlin
import matplotlib.pyplot as plt
import pygame
from slider import LabeledSlider
from menus import Menu, GenerationMenu, WelcomeMenu, HelpMenu, MapMenu, ImportMenu

import pygame_widgets
from pygame_widgets.textbox import TextBox
from pygame_widgets.button import Button



import numpy as np
# best way to implement this into pygame. 
# want to be able to edit the map in the future? 
# pixel by pixel storage of colours? 
# have a noisemap, as generated by noise functions. Want pygame to handle purely the map, so we can make alterations to it before?
# want to be combining multiple maps into biome mappings. 
# so maybe 3 maps combined, and then each twile is assigned a biome texture. 
# need to account for biome texture options? IF can upload an image, then probably don't want to just assign a colour. Although for time being maybe the best option.
# perhaps make the noise map generated the same size as the default pygame window 

#todo
#ocean depth colouring, same with mountains etc.

# initialise pygame and constants
pygame.init()
WIDTH = 1024
HEIGHT = 756
perlin_width = 512
perlin_height = 512
MENU_WIDTH = 256


class Program():
    def __init__(self, screen):
        self.screen = screen
        
        self.WIDTH = 1024
        self.HEIGHT = 756
        self.perlin_width = 512
        self.perlin_height = 512
        self.MENU_WIDTH = 256

        self.current_window = WelcomeMenu(screen,0,0, self.screen_change)
        self.windows = {        # have windows be displayed depedning on activity                  # give windows an "on" and an "off" attribute.        

            "WELCOME": self.current_window,
            "GENERATION": GenerationMenu(screen, 0,0, self.MENU_WIDTH, None),
            "IMPORT": ImportMenu(screen, 0,0),
            "HELP": HelpMenu(screen, 0,0),
            "MAP": MapMenu(screen, 0,0)
        } 
        
        for val in self.windows.values():
            val.hide_self()


        self.running = True

        #pygame variables
        self.events = pygame.event.get()
        self.clock = pygame.time.Clock()
        self.FPS = 60

        print(self.current_window)


    def run(self):
        if self.run:
            self.events = pygame.event.get()

            self.current_window.show_self()

            for event in self.events:
                if event.type == pygame.QUIT:
                            self.run = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    pos = pygame.mouse.get_pos()
                    print(pos)
                    try:
                        print(noise_map[pos[0]][pos[1]])
                    except:
                        pass


            self.screen.fill((255,255,255))
            pygame_widgets.update(self.events)
            
            pygame.display.flip()
            self.clock.tick(self.FPS)   
    
    def test(self):
        print("Test")


    def screen_change(self, key):
        self.current_window.hide_self()
        self.current_window = self.windows[key]

        print(self.windows)



screen = pygame.display.set_mode((WIDTH+MENU_WIDTH, HEIGHT), flags=pygame.RESIZABLE)
clock = pygame.time.Clock()
FPS = 60



def generate_perlin_map(perlin_width=perlin_width, perlin_height=perlin_height, octaves= 1, frequency= 1, amplitude= 1, persistence=0.5, lacunarity= 2, SEED= 0): # default values
    noise_map = perlin(perlin_width,perlin_height,octaves, frequency, amplitude, persistence, lacunarity, SEED)
    return noise_map

def rgb_perlin_mask(noise_map, blue_bound=-0.15, green_bound=0.3):
    print(locals())
    global perlin_width, perlin_height
    rgb_array = np.zeros((perlin_width,perlin_height,3), dtype=np.uint8) # 3 deep for RGB, unit provides range from 0-255
    # boolean array indexing, masks perlin values to colour
    rgb_array[(noise_map >= -1) & (noise_map < blue_bound)] = (0,0,255) # blue masking
    rgb_array[(noise_map >= blue_bound) & (noise_map < green_bound)] = (0,255,0) # green masking
    rgb_array[(noise_map >= green_bound) & (noise_map <= 1.0)] = (190,190,190) # gray masking

    return rgb_array # returns an array of rgb values, and the originally generated perlin noise map. 

# def gen_map_in_class():
#     params = generation_menu.get_params()

#     noise_map = generate_perlin_map(
#         perlin_width,
#         perlin_height, 
#         octaves= params["octaves"], 
#         frequency=params["frequency"], 
#         amplitude=params["amplitude"], 
#         persistence=params["persistence"], 
#         lacunarity=params["lacunarity"], 
#         SEED= 0)
    
#     global rgb_array

#     rgb_array = rgb_perlin_mask(noise_map,
#         blue_bound=params["blue_boundary"], 
#         green_bound=params["green_boundary"])  
    

map_surf = pygame.Surface((perlin_width, perlin_height)) # map surface
noise_map  = generate_perlin_map()
rgb_array = rgb_perlin_mask(noise_map)

noise_map = perlin(perlin_width,perlin_height,frequency=4, octaves=6, SEED=2) # np array


pmain = Program(screen)


# 12/10/2025 - currently at the point of implementing screens. need to create a welcome menu screen and implement true/false switching within the program class. then work on page nav & adding a perlin function into the program classs. 

#run loop
running = True
while running:
    pmain.run()



# print(slider_vars)